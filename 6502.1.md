# Checking out the repository

sudo apt-get install clang ninja cmake

TODO: Figure out how to properly get the source to llvm and clang
so that you can push to your own repo in github.

Assume you checked out llvm into llvmsrc.

```
mkdir llvmbuild
cd llvmbuild
```

## Build the ninja makefiles

Specifying at least one experimental target and one non-experimental target.

```
cmake -G Ninja -DCMAKE_BUILD_TYPE=Debug -DBUILD_SHARED_LIBS=True \
  -DLLVM_OPTIMIZED_TABLEGEN=True -DLLVM_BUILD_TESTS=True \
  -DCMAKE_C_COMPILER=clang -DCMAKE_CXX_COMPILER=clang++ \
  -DLLVM_EXPERIMENTAL_TARGETS_TO_BUILD="RISCV" 
  -DLLVM_TARGETS_TO_BUILD=WebAssembly ../llvmsrc/llvm
```

## Build llvm and clang

This will take a few hours.

```
cmake --build .
```

`bin/llvm-mc -version` will show the targets built.

# Adding the triple

The name of the target needs to be added to:
  * include/llvm/ADT/Triple.h
  * lib/Support/Triple.cpp

## Modifications to `Triple.h`

We add the *architecture type* `mcs6502` to the enum `Triple::ArchType` in `Triple.h`. Add it alphabetically, as closely as possible.

## Modifications to `Triple.cpp`

Add a mapping from the ArchType to a name in `getArchTypeName()`.

Add a mapping from the ArchType to a name prefix in `getArchTypePrefix()`. If there are multiple architectures, the prefix common to the names is what is returned. Otherwise just return the name.

Add a mapping from the name to the ArchType in `getArchTypeForLLVMName()`.

Add mappings from the name to the ArchType in `parseArch()`.

Add a mapping from the ArchType to an object format in `getDefaultFormat()`. For the 6502, we will choose ELF, and hope that once we have an executable, we can translate to a raw binary image.

Add a mapping from the ArchType to the pointer bit width in `getArchPointerBitWidth()`. For the 6502, this is 16.

Add a mapping from the ArchType to the 32-bit variant in `get32BitArchVariant()`. Since there is no such variant for the 6502, we call `T.setArch` with `UnknownArch`.

Similarly, we add a mapping from the ArchType to the 64-bit variant in `get64BitArchVariant()`.

We add a mapping from the ArchType to the big-endian variant in `getBigEndianArchVariant()`. Since there is none, we call `T.setArch` with `UnknownArch`.

Finally, we map the ArchType to a boolean which indicates whether the architecture is little endian natively in `isLittleEndian()`.

## Recompile

We still have no backend files, so we still don't have an additional target.

This will take almost as long as the first time, since pretty much every file eventually depends on `Triple.h`.

```
cmake --build .
```

## Add some tests

We will add three tests to `unittest/ADT/TripleTest.cpp`.

The first test, added to `ParsedIDs`, ensures that `mcs6502-unknown-unknown` parses properly:

```
T = Triple("mcs6502-unknown-unknown");
EXPECT_EQ(Triple::mcs6502, T.getArch());
EXPECT_EQ(Triple::UnknownVendor, T.getVendor());
EXPECT_EQ(Triple::UnknownOS, T.getOS());
EXPECT_EQ(Triple::UnknownEnvironment, T.getEnvironment());
```

Next, a test added to `BitWidthPredicates` that ensures that the pointer size was correctly set:

```
T.setArch(Triple::mcs6502);
EXPECT_TRUE(T.isArch16Bit());
EXPECT_FALSE(T.isArch32Bit());
EXPECT_FALSE(T.isArch64Bit());
```

Finally, a test added to `BitWidthArchVariants` that ensures the pointer size variants were correctly set:

```
T.setArch(Triple::mcs6502);
EXPECT_EQ(Triple::UnknownArch, T.get32BitArchVariant().getArch());
EXPECT_EQ(Triple::UnknownArch, T.get64BitArchVariant().getArch());
```

We can then run the test to ensure nothing went wrong:

```
cmake --build .
unittests/ADT/ADTTests
```
