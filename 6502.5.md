# Part 5: Disassembler

Now that we have something that can convert from assembly language to an object file, we now need something that can do the reverse. This is where the disassembler comes in.

The disassembler is used by the `llvm-objdump` program when it reads an object file and prints various information about it. You can use the `-d` option to show the disassembly of an object file.

## How it works

The `llvm-objdump` program takes an object file, parses it, and passes code bytes to the disassembler. The disassembler takes the code bytes and converts them to an `MCInst` (Machine Code Instruction). It does this using code generated from the tablegen files we built in the previous part to define the instructions and registers.

## MCDisassembler

We need to create a subclass of `MCDisassembler`. To start, we create a `Disassembler` directory and populate it with the usual `CMakeFiles.txt` and `LLVMBuild.txt` files.

* `CMakeFiles.txt`: Add an llvm_library called `LLVMMCS6502Disassembler` and add the `MCS6502Disassembler.cpp` file to it.
* `LLVMBuild.txt`: Create a `Library` component named `MCS6502Disassembler` whose parent and library group is `MCS6502`.

```
[component_0]
type = Library
name = MCS6502Disassembler
parent = MCS6502
required_libraries = MCDisassembler MCS6502Info Support
add_to_library_groups = MCS6502
```

We must also have `tablegen` generate the tables for the disassembler that will help it decode instructions. This means adding to the top-level `CMakeFiles.txt` a line:

```
tablegen(LLVM MCS6502GenDisassembler.inc -gen-disassembler)
```

And, of course, adding the `Disassembler` subdirectory to the list of subdirectories in both `CMakeFiles.txt` and `LLVMBuild.txt`. We also tell `LLVMBuild.txt` that `has_disassembler = 1`.

The disassembler subclass contains, aside from the constructor, the `getInstruction()` function.

The cpp file also contains a hook for LLVM to create the disassembler instance, and to register it for the target machine.

```
static MCDisassembler *createMCS6502Disassembler(const Target &T,
                                                 const MCSubtargetInfo &STI,
                                                 MCContext &Ctx) {
  return new MCS6502Disassembler(STI, Ctx);
}

extern "C" void LLVMInitializeMCS6502Disassembler() {
  TargetRegistry::RegisterMCDisassembler(getTheMCS6502Target(),
                                         createMCS6502Disassembler);
}
```

Another modification we have to make is to the instruction records. Now they all need a 32-bit SoftFail field. It must be present, but it does not have to be used. It is apparently used mainly for the ARM targets.

## `MCS6502Disassembler::getInstruction()`

`getInstruction()` receives the bytes in the object file starting at the beginning of the instruction. We simply pass the bytes to the generated `decodeInstruction()` function, along with the table it should use: `DecoderTable8`, `DecoderTable16`, or `DecoderTable24`. Since we don't know which we need, we can pass the first byte for `DecoderTable8` and look at the result. If it was unsuccessful, we move on to `DecoderTable16`, and so on.

`getInstruction()` must also give back the size in bytes of the instruction we disassembled successfully, which is easy since it just depends on which decoder table resulted in a success.

It must also give back an `MCInst`. The work for this is done by the generated code using the instruction formats we wrote in the previous part.

For now we'll just add the `getInstruction()` function to see what happens.

# Add the tests

For testing the disassembler, we modify the `valid.s` file to include a second pass-through to first compile through `llvm-mc`, then disassemble through `llvm-objdump` and ensure that the output is the same.

```
; RUN: llvm-mc %s -triple=mcs6502 -filetype=obj \
; RUN:     | llvm-objdump -d - | FileCheck -check-prefixes=CHECK-INST %s
```

Running this test causes the first few instructions to decode properly, but we get a core dump when we try to disassemble `ADC (0x12, X)`. It's able to print up to `ADC (0x12, ` but then fails. All the previous instructions were simple immediate values, but this is the first complex operand.

The error happens in our `MCS6502InstPrinter::printOperand()` function where we're trying to get a given operand from the `MCInst` but there aren't that many operands. These operands were added by the generated code in `MCS6502GenDisassemblerTables.inc`. Looking at that file, we can see that the `decodeToMCInst()` function is only decoding operands as immediate values, but `ADC (0x12, X)` should have a `zp_preind` operand.

To fix this, we add `let PrintMethod="decodePreIndOperand";` to the operand in `MCS6502InstFormats.td`. Recompiling now will complain that `decodePreIndOperand()` is nowhere to be found! We must define this function in `MCS6502Disassembler.cpp`, as a static function.

In this function, we want to add `MCOperands` to the `MCInst` being constructed. The generated code is looking for two operands because that's what is in the `AsmString` for the instruction. We might want this to match up with what we generated during assembly in the previous part, but in this case we want to add the two MCOperands that are expected: an immediate and a register so that we can display the "X" portion of the instruction:

```
static DecodeStatus decodePreIndOperand(MCInst &Inst, uint64_t Val, int64_t Address, const void *Decoder) {
  assert(isUInt<8>(Val) && "Invalid PreInd operand");
  Inst.addOperand(MCOperand::createImm(Val));
  Inst.addOperand(MCOperand::createReg(MCS6502::X));
  return MCDisassembler::Success;
}
```

Now we can do the same thing for the other register-taking instructions, except for the accumulator instructions which don't actually have any operands.

The accumulator instructions give us a different problem: the disassembler is expecting one operand, a register, but we don't even get the chance to decode the operand. The reason is that there are no bits in the instruction that actually encode different registers. So when can we add the register operand?

Instead of letting the autogenerated disassembler decode these instructions, we can use a custom decoder. By setting the `DecoderMethod` of an instruction record, the disassembler will call it:

```
let DecoderMethod = !if(!eq(mode.Value, MODE_ACC.Value), "decodeAccOperand", "");
```

I was able to construct this expression by looking at the [tablegen language introduction](https://llvm.org/docs/TableGen/LangIntro.html).

We can define the (static) function in `MCS6502Disassembler.cpp` just like the operand decoding functions we defined.

And that's it! Running the test shows that we've successfully handled all the instruction types.
