# Part 6: Fixups for symbols

Rather than having to hardcode values, it would be nice to use symbols or identifiers. LLVM has built-in directives where you can define a value, such as:

```
sta myval16

.set myval8, 0x12
.set myval16, 0x1234

ldx #myval8
```

Note that references can be forward or backward.

We can also includes labels, which are, in a sense, the same as substituting for values:

```
.LBB0

bcc .LBB0
jmp .LBB1

.LBB1
```

These kinds of substitutions which happen after assembly are called variously *fixups* or *relocations*.

# Adding relocation types

From the above, we can define three types: substituting for an 8-bit value, a 16-bit value, and a branch. We define these types in `include/llvm/BinaryFormat/ELFRelocs/MCS6502.def`. In effect, these values tell whatever is processing an ELF object file to substitute this for that.

```
ELF_RELOC(R_MCS6502_NONE, 0)
ELF_RELOC(R_MCS6502_SYMBOL8, 1)
ELF_RELOC(R_MCS6502_SYMBOL16, 2)
ELF_RELOC(R_MCS6502_BRANCH, 3)
```

Next we add `MCTargetDesc/MCS6502FixupKinds.h` to create a `Fixups` enum.

# Implementing relocations

Next, we override `MCAsmBackend::getFixupKindInfo` in `MC6502AsmBackend`. This returns the offset into the instruction and the number of bits for the value to fix up.

Then we write `MCAsmBackend::applyFixup()` which takes the `MCFixup` to apply and applies the given `Value` to the `Data` bytes given.

Next, in `MCS6502ELFObjectWriter.cpp`, we change `getRelocType()` to return the `ELF_RELOC` values we defined in `ELFRelocs/MCS6502.def`.

Then, in `MCS6502MCCodeEmitter.cpp`, we change `getMachineOpValue()` to use the fixups.

Now, `encodeInstruction()` is called by `MCAsmStreamer::AddEncodingComment()`, via a long chain ultimately called by `MCS6502AsmParser::MatchAndEmitInstruction()` when it calls `Out.EmitInstruction`.

In `encodingInstruction()`, we call the generated `getBinaryCodeForInstr()`, which returns 64 bits. For each operand, it calls `getMachineOpValue()` so that it can put those bits in the right place in the instruction. Bits in the operand that can't yet be determined (i.e. they must be fixed up later) are 0, and a Fixup is placed by `getMachineOpValue()` in the Fixups vector.

Finally, we have to fix the print functions in `MCS6502InstPrinter` so that they can print unfixed-up operands (which are expressions).

# Tests

We add a test to check the fixups in `test/MC/MCS6502/fixups.s`.

First we'll test that value fixups work:

```
; RUN: llvm-mc %s -triple=mcs6502 -show-encoding \
; RUN:     | FileCheck -check-prefixes=CHECK-FIXUP %s
; RUN: llvm-mc %s -triple=mcs6502 -filetype=obj \
; RUN:     | llvm-objdump -d - | FileCheck -check-prefixes=CHECK-INST %s
; RUN: llvm-mc %s -triple=mcs6502 -filetype=obj \
; RUN:     | llvm-readobj -r | FileCheck -check-prefixes=CHECK-REL %s

lda val16
; CHECK-FIXUP: fixup A - offset: 0, value : val16, kind: fixup_mcs6502_symbol16
sta val8
; CHECK-FIXUP: fixup A - offset: 0, value : val8, kind: fixup_mcs6502_symbol16
ldx #val16
; CHECK-FIXUP: fixup A - offset: 0, value : val16, kind: fixup_mcs6502_symbol8
ldy #val8
; CHECK-FIXUP: fixup A - offset: 0, value : val8, kind: fixup_mcs6502_symbol8

.set val16, 0x1234
.set val8, 0xAB
```

Note that for the first two instructions, we expect to choose the default absolute encoding (16 bits) rather than the zero-page encoding. Furthermore, the last two instructions must have an 8-bit operand.

This results in this encoding (running `llvm-mv` with `-show-encoding`):

```
	LDA val16                       ; encoding: [0xad,A,A]
                                        ;   fixup A - offset: 0, value: val16, kind: fixup_mcs6502_symbol16
	STA val8                        ; encoding: [0x8d,A,A]
                                        ;   fixup A - offset: 0, value: val8, kind: fixup_mcs6502_symbol16
	LDX #val16                      ; encoding: [0xa2,A]
                                        ;   fixup A - offset: 0, value: val16, kind: fixup_mcs6502_symbol8
	LDY #val8                       ; encoding: [0xa0,A]
                                        ;   fixup A - offset: 0, value: val8, kind: fixup_mcs6502_symbol8

.set val16, 4660
.set val8, 171
```

Notice that the unknown values in the encoded instructions are symbolized by "A", and "fixup A" describes the fixup that needs to be applied.

If now we run `llvm-mc` with `-filetype=obj` and send the output to `llvm-objdump -d -`, we see the disassembly:

```
       0:	ad 34 12 	LDA 0x1234
       3:	8d ab 00 	STA 0xab
       6:	a2 34 	LDX #0x34
       8:	a0 ab 	LDY #0xab
```

This shows that the fixups were successfully applied. Note that the second instruction was absolute rather than zero-page. This is because it was not known at the time of choosing the instruction mode whether the operand was going to be absolute or zero-page, so the default was absolute. We will fix this in a later part by applying a *relaxation*.

# Handling branch labels

In `MCS6502MCCodeEmitter::getMachineOpValue()`, we set the fixup kind to `MCS6502::fixup_mcs6502_branch` if `isConditionalBranch()` for the instruction is true. However, none of our instruction records set this to true. 

`MCInstrDesc::isConditionalBranch()` returns true if `isBranch()` is true, `isBarrier()` is false, and `isIndirectBranch()` is false. Each of these is set by setting appropriate flags in the instructino record. So, we will define a new instruction record in `MCS6502InstrFormats.td` which has these flags set:

```
class cond_branch_inst<string mnemonic, bits<8> opcode> :
    Inst2Byte<mnemonic, opcode, MODE_REL, (outs)> {
  // Together these make isConditionalBranch true.
  let isBranch = 1;
  let isBarrier = 0;
  let isIndirectBranch = 0;
}
```

And then we redefine all our conditional branch instructions in terms of this record.

```
def BPL : cond_branch_inst<"BPL", 0x10>;
def BMI : cond_branch_inst<"BMI", 0x30>;
def BVC : cond_branch_inst<"BVC", 0x50>;
def BVS : cond_branch_inst<"BVS", 0x70>;
def BCC : cond_branch_inst<"BCC", 0x90>;
def BCS : cond_branch_inst<"BCS", 0xB0>;
def BNE : cond_branch_inst<"BNE", 0xD0>;
def BEQ : cond_branch_inst<"BEQ", 0xF0>;
```

We can test this by adding some labels and branches in `fixups.s`:

```
.LBB0:
tay

bcc .LBB0
; CHECK-INST: bcc #0xff
; CHECK-FIXUP: fixup A - offset: 0, value: .LBB0, kind: fixup_mcs6502_branch

bcs .LBB1
; CHECK-INST: bcs #0x12
; CHECK-FIXUP: fixup A - offset: 0, value: .LBB1, kind: fixup_mcs6502_branch

.fill 16
.LBB1:
tay
```

The encoding:

```
.LBB0:
	TAY                             ; encoding: [0xa8]


	BCC .LBB0                       ; encoding: [0x90,A]
                                        ;   fixup A - offset: 0, value: .LBB0, kind: fixup_mcs6502_branch

	BCS .LBB1                       ; encoding: [0xb0,A]
                                        ;   fixup A - offset: 0, value: .LBB1, kind: fixup_mcs6502_branch

	.fill	16, 1, 0x0
.LBB1:
	TAY                             ; encoding: [0xa8]
```

And the disassembly, showing that the offsets were calculated correctly. This was the result of setting the `MCFixupKindInfo::FKF_IsPCRel` flag in `MCS6502AsmBackend::getFixupKindInfo`.

```
       a:	a8 	TAY 
       b:	90 ff 	BCC 0xff
       d:	b0 12 	BCS 0x12
		...
      1f:	a8 	TAY 
```

# Handling unconditional jumps

For `JMP` and `JSR`, their operand will end up being a 16-bit reference to a symbol. However, we will not be able to fix up the value for disassembly, since an object file without a fixed address is relocatable: none of the addresses are known at the time of disassembly. It is only during link time that all these addresses get resolved.

So, we can include these instructions in our tests but we'll just end up getting zero for the operands:

```
	JMP .LBB1                       ; encoding: [0x4c,A,A]
                                        ;   fixup A - offset: 0, value: .LBB1, kind: fixup_mcs6502_symbol16
	JSR .LBB0                       ; encoding: [0x20,A,A]
                                        ;   fixup A - offset: 0, value: .LBB0, kind: fixup_mcs6502_symbol16
```

```
      20:	4c 00 00 	JMP 0x0
      23:	20 00 00 	JSR 0x0
```
