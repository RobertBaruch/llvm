# Part 4: Registers and Instructions

## Tablegen

*tablegen* is an LLVM program and domain-specific language to generate classes and enums from *records* in `.td` files. Running tablegen with various flags generates `.inc` files. Different parts of the `.inc` file can be included in `.h` or `.cpp` files by `#define`s.

## Files

* `lib/Target/MCS6502/CMakeLists.txt` to add tablegen commands
* `lib/Target/MCS6502/MCS6502.td`
* `lib/Target/MCS6502/MCS6502InstrFormats.td` for instruction formats which help define instructions
* `lib/Target/MCS6502/InstrInfo.td` for instructions
* `lib/Target/MCS6502/MCS6502RegisterInfo.td` for registers

## Build file

We add tablegen commands to `CMakeLists.txt`.

## Adding `MCS6502.td`

This file is a kind of master file for tablegen. It includes `llvm/Target/Target.td` which includes lots of useful record definitions.

We define `MCS6502InstrInfo`, just a straight subclass of `InstrInfo`.

We define an enumeration for a processor model. More could be defined it there were other processors in the same family.

We also define a class, `MCS6502`, which subclasses `Target` (which is defined in `Target.td`), and we set the `InstructionSet` field to `MCS6502InstrInfo`.

## Adding `MCS6502RegisterInfo.td`

Note that since we are defining things in this file and not using them for anything, we have to reserve the right to change things later on!

First, we will define a subclass of `Register` (defined in `Target.td`) for the MCS6502. `Register` has an `n` argument which is the name of the register, and an `altNames` list argument which gives alternate names for the register. There are other fields within `Register`, but we won't deal with them now.

We know that there are three registers: A, X, and Y. However, the modern processors for which LLVM was designed have many more registers. For this reason, we will also include "pseudo-registers", which are just locations in zero page. The exact locations aren't known at this point, since different machines (e.g. Apple //e, Atari 800) have different uses for zero page.

It seems it would be useful to have two subclasses, one for physical registers, and one for pseudo registers. We will define A, X, and Y as physical registers, and define 32 pseudo registers using a `foreach` block.

All the classes we define will be in the `MCS6502` namespace. Ordinarily this would require a `let Namespace="MCS6502";` line in classes, but instead we use the scoping form of this command (`let ... in { }`) to define this in every class in the scope.

We also define two register classes, one for all physical registers, and one for all pseudo registers. They are defined in terms of `RegisterClass`, which takes a namespace, a list of `ValueType`s that the registers in the class can take, the alignment, and the list of registers themselves (in preferred allocation order).

`ValueType` is defined in `include/llvm/CodeGen/ValueTypes.td`. Since all of our registers are 8-bit, they all take `i8`. We could go further and bundle the registers up into 32-bit registers with sub-registers, but we will not do that now.

The list of registers isn't actually a list, but a *dag* (directed acyclic graph). A dag is basically a tree of nodes.

## Adding `MCS6502InstrFormats.td`, `MCS6502InstrInfo.td`

The instruction formats tell us how to encode an instruction. All instructions eventually subclass from `Instruction` (defined in `Target.td`).

There are many fields in an `Instruction`, but the most important ones for now are:
* `Namespace`: The namespace the instruction lives in.
* `AsmString`: A format to print and parse the instruction with.
* `Size`: The size of the instruction in bytes.
* `OutOperandList`: A dag for the outputs of the instruction. The root node of the dag is `(outs)`.
* `InOperandList`: A dag for the inputs of the instruction. The root node of the dag is `(ins)`.
* `Inst`: Not actually a field, but must be defined. The final encoding of the instruction.

We know about all the 6502 addressing modes. Each addressing mode has its own format. So for example, the "Zero Page, X" addressing mode looks like `ADC $5C,X`. One of the problems, though, is that LLVM's assembly language parser is limited to C-style integers, which means `0x5C` rather than `$5C`.

There are many other gotchas, so we're only going to define a single instruction so that we can see what the problems are. Then we can define all the other instructions.

```
def ADC_INDX : Instruction {
  let Namespace = "MCS6502";

  bits<24> Inst;
  bits<16> addr;

  let Size = 3;
  let Inst{23-16} = 0x61;
  let Inst{15-8} = addr{7-0};
  let Inst{7-0} = addr{15-8};
  let AsmString = "ADC ($addr,X)";
  let OutOperandList = (outs);
  let InOperandList = (ins i16imm:$addr);
}
```

We're just going to naively set the `AsmString` to `"ADC ($addr,X)"`. The `$addr` is a reference to an operand. This operand is an input operand, so it goes in the `InOperandList`: `(ins i16:$addr)`. The children of the `(ins)` node are `type:reference` pairs. The type must be a subclass of `Operand`. `Target.td` has several predefined, so we will use `i16imm`, a 16-bit immediate integer value.

# Add an AsmParser

# Add test

In `test/MC/MC6502/valid.s` we add this test:

```
; RUN: llvm-mc %s -triple=mcs6502 -show-encoding \
; RUN:     | FileCheck -check-prefixes=CHECK,CHECK-INST %s

; CHECK-INST: adc (0x1234,X)
; CHECK: encoding: [0xa8]
adc (0x1234,X)
```

However, this will not run unless we also add an InstPrinter.

# Add an InstPrinter

