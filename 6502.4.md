# Part 4: Registers and Instructions, Assembler

## Goal

The goal of this part is to build an assembler that can take a .s file and output an object file. We will only accept hard-coded values in the assembly, since identifiers and external symbols need fixup passes which we won't target yet.

## Tablegen

*tablegen* is an LLVM program and domain-specific language to generate classes and enums from *records* in `.td` files. Running tablegen with various flags generates `.inc` files. Different parts of the `.inc` file can be included in `.h` or `.cpp` files by `#define`s.

## How it works

The `llvm-mc` program takes a .s file containing *assembly language* and converts it to an object file containing *machine code*.

We first need to provide tablegen records describing what registers exist, what instructions exist, and how to convert an instruction with known operands to machine code.

Then, we create a subclass of `AsmParser` subclass. `llvm-mc` will pass each line of assembly to the `AsmParser`, which must respond by parsing the line and giving back a list of typed operands found. Such operands may be values, expressions, or even bare tokens. These operands are target-specific subclasses of `MCParsedAsmOperand` -- `MC` for Machine Code, and `Parsed` because this is from the parsing step.

Next, LLVM will look at each instruction record's `AsmString` and try to construct an `MCInst` (Machine Code Instruction) by matching the operands parsed with the format given in the `AsmString`. The `AsmString` contains "formal" operands whose types are also defined in `.td` records. The target-specific code is responsible for converting each matched `MCParsedAsmOperand` to an `MCOperand` that gets added to the `MCInst` being built.

While we can carry around any information we want in our target-specific `MCParsedAsmOperand`, `MCOperand` only has a few abilities:

* Have a register.
* Have a specific immediate integer value.
* Have a specific immediate floating point value.
* Have an *expression* of type `MCExpr`.
* Have another `MCInst`.

This adds a lot of flexibility -- especially for `MCExpr` which can be a binary or unary expression (e.g. plus, logical-and), a constant, a symbol reference, or even a target-specific subclass.

Once LLVM has the `MCInst` for the line of assembly, it converts it to the machine code representation of the assembly and writes it to the output ELF object file.

# Files

* `lib/Target/MCS6502/CMakeLists.txt` to add tablegen commands
* `lib/Target/MCS6502/MCS6502.td`
* `lib/Target/MCS6502/MCS6502InstrFormats.td` for instruction formats which help define instructions
* `lib/Target/MCS6502/InstrInfo.td` for instructions
* `lib/Target/MCS6502/MCS6502RegisterInfo.td` for registers

## Build file

We add tablegen commands to `CMakeLists.txt`.

## Adding `MCS6502.td`

This file is a kind of master file for tablegen. It includes `llvm/Target/Target.td` which includes lots of useful record definitions.

We define `MCS6502InstrInfo`, just a straight subclass of `InstrInfo`.

We define an enumeration for a processor model. More could be defined it there were other processors in the same family.

We also define a class, `MCS6502`, which subclasses `Target` (which is defined in `Target.td`), and we set the `InstructionSet` field to `MCS6502InstrInfo`.

## Adding `MCS6502RegisterInfo.td`

Note that since we are defining things in this file and not using them for anything, we have to reserve the right to change things later on!

First, we will define a subclass of `Register` (defined in `Target.td`) for the MCS6502. `Register` has an `n` argument which is the name of the register, and an `altNames` list argument which gives alternate names for the register. There are other fields within `Register`, but we won't deal with them now.

We know that there are three registers: A, X, and Y. However, the modern processors for which LLVM was designed have many more registers. For this reason, we will also include "pseudo-registers", which are just locations in zero page. The exact locations aren't known at this point, since different machines (e.g. Apple //e, Atari 800) have different uses for zero page.

It seems it would be useful to have two subclasses, one for physical registers, and one for pseudo registers. We will define A, X, and Y as physical registers, and define 32 pseudo registers using a `foreach` block.

All the classes we define will be in the `MCS6502` namespace. Ordinarily this would require a `let Namespace="MCS6502";` line in classes, but instead we use the scoping form of this command (`let ... in { }`) to define this in every class in the scope.

We also define two register classes, one for all physical registers, and one for all pseudo registers. They are defined in terms of `RegisterClass`, which takes a namespace, a list of `ValueType`s that the registers in the class can take, the alignment, and the list of registers themselves (in preferred allocation order).

`ValueType` is defined in `include/llvm/CodeGen/ValueTypes.td`. Since all of our registers are 8-bit, they all take `i8`. We could go further and bundle the registers up into 32-bit registers with sub-registers, but we will not do that now.

The list of registers isn't actually a list, but a *dag* (directed acyclic graph). A dag is basically a tree of nodes.

## Adding `MCS6502InstrFormats.td`, `MCS6502InstrInfo.td`

The instruction formats tell us how to encode an instruction. All instructions eventually subclass from `Instruction` (defined in `Target.td`).

There are many fields in an `Instruction`, but the most important ones for now are:
* `Namespace`: The namespace the instruction lives in.
* `AsmString`: A format to print and parse the instruction with.
* `Size`: The size of the instruction in bytes.
* `OutOperandList`: A dag for the outputs of the instruction. The root node of the dag is `(outs)`.
* `InOperandList`: A dag for the inputs of the instruction. The root node of the dag is `(ins)`.
* `Inst`: Not actually a field, but must be defined. The final encoding of the instruction.

We know about all the 6502 addressing modes. Each addressing mode has its own format. So for example, the "Zero Page, X" addressing mode looks like `ADC $5C,X`. One of the problems, though, is that LLVM's assembly language parser is limited to C-style integers, which means `0x5C` rather than `$5C`.

There are many other gotchas, so we're only going to define a single instruction so that we can see what the problems are. Then we can define all the other instructions.

```
def ADC_INDX : Instruction {
  let Namespace = "MCS6502";

  bits<24> Inst;
  bits<16> addr;

  let Size = 3;
  let Inst{23-16} = 0x61;
  let Inst{15-8} = addr{7-0};
  let Inst{7-0} = addr{15-8};
  let AsmString = "ADC ($addr,X)";
  let OutOperandList = (outs);
  let InOperandList = (ins i16imm:$addr);
}
```

We're just going to naively set the `AsmString` to `"ADC ($addr,X)"`. The `$addr` is a reference to an operand. This operand is an input operand, so it goes in the `InOperandList`: `(ins i16:$addr)`. The children of the `(ins)` node are `type:reference` pairs. The type must be a subclass of `Operand`. `Target.td` has several predefined, so we can use `i16imm`, a 16-bit immediate integer value.

Also note that the name of the `addr` field in the `Instruction` must match the reference name in the `AsmString`.

# Add a test

In `test/MC/MC6502/valid.s` we add this test:

```
; RUN: llvm-mc %s -triple=mcs6502 -show-encoding \
; RUN:     | FileCheck -check-prefixes=CHECK,CHECK-INST %s

; CHECK-INST: adc (0x1234,X)
; CHECK: encoding: [0x61 0x34 0x12]
adc (0x1234,X)
```

However, this will not run unless we also add an AsmParser and an InstPrinter.

# Add an AsmParser

## How it works

When `llvm-mc` grabs a `.s` file, it parses it. For each line, as long as it doesn't start with a comment, the mnemonic is the identifier found after zero or more labels that is not also one of the pre-defined directives that start with a dot.

Running `llvm-mc` with `-triple=mcs6502 -show-encoding -debug` gives us lots of information to work with.

`AsmParser::parseStatement` is called for each line, which passes the mnemonic to the target-specific AsmParser's `ParseInstruction()` method. This function must parse the rest of the instruction via `getLexer()` and `getParser()`, placing any operands found in the `Operands` vector. The first operand must always be a `Token` containing the mnemonic. The other operands must be of type `<Target>Operand`, which we write in `MCS6502AsmParser.cpp`.

After getting all the operands parsed, `AsmParser::parseStatement` calls the target-specific AsmParser's `MatchAndEmitInstruction()` method with the operands found.

So if `0x1234` were encoded as an operand, and nothing else, there would be no difference between `adc (0x1234,X)` and `adc (0x1234),Y`. So we need to make sure we have an Operand *definition* that includes information about whether it's indirect and what register is used. We write these operand definitions in `MCS6502InstrInfo.td`.

We can't subclass `i16imm` because that is a `def` rather than a `class`, so we're just going to define `i16ind`, `i16reg_preind`, and `i16reg_postind` for indirect and register indirect operands, all of which are subclassed from `Operand<i16>`. 

```
def i16ind : Operand<i16> {

}

def i16reg_preind : Operand<i16> {
  MCS6502Reg reg;
}

def i16reg_postind : Operand<i16> {
  MCS6502Reg reg;
}

def ADC_INDX : Instruction {
  let Namespace = "MCS6502";

  bits<24> Inst;
  bits<16> addr;

  let Size = 3;
  let Inst{23-16} = 0x61;
  let Inst{15-8} = addr{7-0};
  let Inst{7-0} = addr{15-8};
  let AsmString = "ADC ($addr,X)";
  let OutOperandList = (outs);
  let InOperandList = (ins i16reg_preind:$addr);
}
```

What's the relationship between these operand definitions and `MCS6502Operand`?

As stated above, after getting all the operands parsed, `AsmParser::parseStatement` calls the target-specific AsmParser's `MatchAndEmitInstruction()` method with the operands found. `MatchAndEmitInstruction()` basically calls the automatically-generated `MatchInstructionImpl()` function (in `MCS6502GenAsmMatcher.inc`).

`MatchInstructionImpl()` goes through all Instruction structures defined that have the same first word in the AsmString field. Note that this is a case-sensitive comparison, which is why we convert the mnemonic given to `ParseInstruction()` to uppercase before putting it in the first operand.

For each such Instruction found, `MatchInstructionImpl()` goes through each operand in the Operands vector and matches it against the stuff found in the rest of the `AsmString` field.

This is a problem, because we added strings to the `AsmString` field. In effect, what `MatchInstructionImpl()` would be looking for is "ADC", followed by "(", followed by an i16reg_preind, followed by "X)" (commas and spaces are token separators and not matched).

To be more general, we can replace X with a register class. For now we'll have a register class consisting only of X, but we could later use the pseudo-registers and replace them with a second pass. For now, though, we will do the simplest thing. Thus, in `MCS6502RegisterInfo.td` we add:

```
def PreIndReg : RegisterClass<"MCS6502", [i8], 8, (add X)>;
```

And we modify the instruction:

```
def ADC_INDX : Instruction {
  let Namespace = "MCS6502";

  bits<24> Inst;
  bits<16> addr;

  let Size = 3;
  let Inst{23-16} = 0x61;
  let Inst{15-8} = addr{7-0};
  let Inst{7-0} = addr{15-8};
  let AsmString = "ADC ($addr, ${reg})";
  let OutOperandList = (outs);
  let InOperandList = (ins i16reg_preind:$addr, PreIndReg:$reg);
}
```

Note that we've had to surround `$reg` with curly braces in order to separate it from `)` in the `AsmString`. This is because tablegen doesn't understand that `)` should end an operand reference name in an `AsmString`.

We have four operands: `(`, an immediate expression, a register, and `)`. So, we need to end up with four operands parsed. To parse this instruction, we have to first detect the '(' `Token`, then parse an `expression`, which allows us to use mathematical expressions and symbols, then parse ',' (not including it as an operand), then a register, then ')'. The important thing to know is that an `expression` can be parenthesized, which is why we can't simply parse an `expression` first. Note also that a comma stops the `expression`. You can see the grammar of `expression` in `lib/MC/MCParser/AsmParser.cpp`.

The next issue is that the matcher needs to know how to match i16reg_preind against what it found. You'd think that we already did that, but maybe it's possible to have the parser be a little more general, and the matcher be more strict. In any case, we have to add a custom matcher to our operand definitions.

To do this, we assign a `ParserMatchClass` to the operand definition. This class then needs to be defined as a subclass of `AsmOperandClass`:

```
def PreIndAsmOperand : AsmOperandClass {
  let Name = "PreInd";
}

def i16reg_preind : Operand<i16> {
  MCS6502Reg reg;

  let ParserMatchClass = PreIndAsmOperand;
}
```

Doing this requires you to add an `add<Name>Operands()` method and an `is<Name>()` method to `MCS6502Operand`. The `add*Operand()` methods add (generally one) `MCOperand` to an `MCInst`.

Now if we run `llvm-mc` on `valid.s`, we get this:

```
	.text

	ADC (0x1234, X)                ; encoding: [0x61,0x34,0x12]
```

If we change the instruction to use Y instead of X:

```
../llvm6502/llvm/test/MC/MCS6502/valid.s:10:13: error: invalid operand for instruction
adc (0x1234,Y)
            ^
```

The caret points to the error because of our use of `SMLoc` in creating the operands.

We can add other (real) instructions, but to make things easy, we add a class hierarchy.

## Parsing "post-indirect" instructions

These are of the form (zero-page-addr), Y. We parse this in the same way as the pre-indirect instructions, using the PostIndRegs class.

## Parsing immediate values

There are two types of immediates, one prefixed with `#` and one with `/`. The former means to take the lowest significant byte, while the latter is for the second lowest significant byte. We add these two characters to `MCS6502AsmParser::ParseInstruction()` and add `parseLowImmediate()` and `parseHighImmediate()` functions.

After `#` or `/` comes an expression. The result must be an 8-bit value, so we could try to construct a new `MCExpr` which optionally logically shifts the parsed `MCExpr` right 8 bits, and then logical-ands with 0xFF.

Adding an IMM class in this way failed, causing a core dump when processing `adc #0xFF`:

```
Unhandled machine op value: <MCOperand Expr:(255&255)>Unhandled expression!
```

Possibly we can't construct an `MCExpr` the way we want to. Removing the fixing of the value, we get a good parse, except `adc /0x1234` fails because `0x1234` isn't an 8-bit number.

Instead, we'll defer handling high-byte immediates until we get to fixups.

`adc #-2` is parsed properly, but results in printing `ADC #0xfffffffffffffffe`. To change this, we go into MCS6502InstPrinter::printOperand(). Currently all we're doing is this:

```
  if (MO.isImm()) {
    llvm::write_hex(O, MO.getImm(), HexPrintStyle::PrefixLower);
    return;
  }
```

The problem here is that we don't know whether we should print an 8-bit number or a 16-bit number -- and instead we're just printing to the host machine's word size (in our case, 64 bits). To fix this, we'll set the `printMethod` field in the Operand's record, adding an `immediate` Operand type, since the built-in `i8imm` isn't doing a good job for us. We then define MCS6502InstPrinter::printImmediate() to print the value the right way.

## Parsing zero-page values

This is just a bare 8-bit value. We'll create a new `MCS6502Operand` Kind for this, `ZP`, so we also add `createZP()`, `isZP()`, `getZPImm()`, and `addZPOperands()`.

We'll also add a `zp` Operand and have its `PrintMethod` also be `printImmediate` since it's an 8-bit value. Its `ParserMAtchClass` will be a new `ZPOperand` class with `Name` set to `ZP`.

In `ParseInstruction()` we add code to parse:

```
  else if (getParser().parseExpression(IdVal) == kParseSuccess) {
    SMLoc E = SMLoc::getFromPointer(S.getPointer() - 1);
    Operands.push_back(MCS6502Operand::createZP(IdVal, S, E));
  }
```

Finally, we add the mode:

```
def MODE_ZP   : Mode<2, "Zero Page", "$val8", (ins zp:$val8)>;
```

An example zero-page instruction `adc 0x36` now parses correctly.

## Parsing absolute values

This is just a bare 16-bit value. We can add the same things as before, but now when parsing an operand and we get an expression, if it fits in an 8-bit value, then we can parse it as ZP, otherwise it's absolute. Note that when we start handling identifiers instead of bare numbers, we won't know what the size is, so we would have to assume absolute and fix up the instruction later if it turns out to be a zero-page access.

So we modify our `ParseInstruction()` section:

```
  else if (getParser().parseExpression(IdVal) == kParseSuccess) {
    SMLoc E = SMLoc::getFromPointer(S.getPointer() - 1);
    if (dyn_cast<MCConstantExpr>(IdVal)) {
      uint64_t val = static_cast<const MCConstantExpr *>(IdVal)->getValue();
      if (val <= 0xFF) {
        Operands.push_back(MCS6502Operand::createZP(IdVal, S, E));
      } else if (val <= 0xFFFF) {
        Operands.push_back(MCS6502Operand::createAbs(IdVal, S, E));
      } else {
        return Error(S, "value must be 16 bits or less");
      }
    } else {
      Operands.push_back(MCS6502Operand::createAbs(IdVal, S, E));
    }
  }
```

Now we get the correct encoding for both instructions:

```
	ADC 0x36                        ; encoding: [0x65,0x36]
	ADC 0x1234                      ; encoding: [0x6d,0x34,0x12]
```

## Parsing absolute,X ZP,X absolute,Y values

Once we've parsed an expression, we need to check if the next token is a comma, and if so, if one of the valid registers follows.

A problem arises with ZP,X and absolute,X. The effective address of a ZP,X instruction is `(ZP+X)&0xFF` while for absolute,X it is `(abs+X)&0xFFFF`. This means that if an expression is a constant 8-bit value, we won't know if the intent was zero-page or not. Presumably `ADC 0x00FF,X` is different from `ADC 0xFF,X`, and yet both will appear as a constant 8-bit expression. There will be a similar problem with identifiers instead of constant expressions, only the problem will appear later during a fixup pass.

We will use these rules:

* If constant, use the size of the constant.
* If this is an expression that includes a symbol explicitly declared as a zero-page symbol via a directive, then use byte.
* Otherwise use word.
  
Note therefore that if abs,X is desired where abs is `0xFF`, then you must declare a symbol and not declare it as a zero-page address.

## More instructions

Now that we've successfully handled ADC, we can handle the other alu-type instructinos: `ORA`, `AND`, `EOR`, `LDA`, `CMP`, and `SBC`.

```
defm ORA : alu_inst<"ORA", 0b000>;
defm AND : alu_inst<"AND", 0b001>;
defm EOR : alu_inst<"EOR", 0b010>;
defm ADC : alu_inst<"ADC", 0b011>;
defm LDA : alu_inst<"LDA", 0b101>;
defm CMP : alu_inst<"CMP", 0b110>;
defm SBC : alu_inst<"SBC", 0b111>;
```

`LDA` is very much like these instructions, but doesn't have the immediate mode.

## Parsing accumulator instructions

There are four instructions that have an accumulator mode: ASL, ROL, LSR, and ROR. The 65C02 introduced accumulator mode for DEC and INC, which we will work on much later when we get into processor variants.

The format for these instructions is `mnemonic A`, so we will use our usual trick of specifying the format as taking a register, and restrict the register to a class containing only the accumulator.

## Relative instructions

The relative instructions take a signed 8-bit operand. We can create a new `rel` Operand, but to differentiate it from an immediate value, we would have to know what the instruction is -- whether it is a branch or not. During `ParseInstruction()`, we haven't exactly nailed down the instruction yet. We could compare to the branch mnemonics, but that's not the best way to do things.

Once the operands are collected by ParseInstruction(), the AsmString will be compared to the operands. The branch instructions will try to match a relative operand, so we need to make sure that isRel() also matches if the operand found is a zero-page operand or even an absolute operand.

We also fix the parse for immediate values to accept small negative values as zero-page operands.

## All the other instructions

We define all the other instructions easily, since they take no operands.
